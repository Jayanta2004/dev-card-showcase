<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ðŸŒ€ One by One Â· idea loom</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: radial-gradient(circle at 30% 10%, #192132, #0b0f1a);
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
    }

    .one-by-one-board {
      max-width: 1000px;
      width: 100%;
      background: rgba(18, 22, 40, 0.75);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: 3.5rem 3.5rem 3rem 3rem;
      box-shadow: 0 30px 50px -20px #000000cc, inset 0 1px 2px rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(160, 180, 255, 0.15);
      overflow: hidden;
      padding: 2.5rem 2rem 2.5rem 2rem;
    }

    /* header zone */
    .board-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem 1.5rem;
      margin-bottom: 3rem;
      padding: 0 0.5rem;
    }

    .title-block {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .title-block h1 {
      font-weight: 500;
      font-size: 2.4rem;
      letter-spacing: -0.5px;
      background: linear-gradient(130deg, #cad2ff, #b1c2ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 10px #4466ee55;
    }

    .step-indicator {
      background: #232946;
      border-radius: 80px;
      padding: 0.5rem 1.5rem 0.5rem 1.2rem;
      border: 1px solid #7f8cff44;
      display: flex;
      align-items: center;
      gap: 0.7rem;
      color: #b7c0ff;
    }

    .step-indicator span {
      font-weight: 300;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .step-number {
      background: #4c5bcd;
      color: white;
      border-radius: 40px;
      padding: 0.2rem 1rem;
      font-weight: 600;
      font-size: 1.5rem;
      line-height: 1.4;
      box-shadow: 0 5px 10px #00000040;
    }

    /* main card â€“ where the single idea lives */
    .idea-stage {
      background: rgba(12, 15, 30, 0.8);
      border-radius: 3rem;
      padding: 2rem 2rem 1.8rem 2rem;
      margin-bottom: 2.2rem;
      border: 1px solid rgba(255, 255, 180, 0.15);
      box-shadow: 0 20px 35px -10px black, inset 0 1px 2px rgba(255, 255, 250, 0.1);
      transition: background 0.2s ease;
    }

    .single-note {
      background: #fcf5e6;
      border-radius: 2rem 2rem 2rem 0.5rem;
      padding: 2.5rem 2.5rem 2rem 2.5rem;
      box-shadow: 15px 15px 0 rgba(0, 0, 0, 0.3), 0 0 0 2px #fffbdd inset, 0 0 0 4px #dbac5b;
      max-width: 700px;
      margin: 0 auto;
      transform: rotate(0.2deg);
      transition: transform 0.2s, box-shadow 0.3s;
      word-wrap: break-word;
    }

    .single-note:hover {
      transform: rotate(0deg) scale(1.01);
      box-shadow: 18px 18px 0 #0000003d, 0 0 0 2px #fff3b5 inset, 0 0 0 4px #e5b45b;
    }

    .idea-content {
      font-size: 1.8rem;
      line-height: 1.5;
      font-weight: 450;
      color: #1f1d13;
      margin-bottom: 2rem;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      min-height: 180px;
      background: rgba(255, 250, 210, 0.3);
      border-radius: 24px;
      padding: 1rem 1.5rem;
      border: 1px dashed #ab8e5a;
      transition: background 0.1s;
    }

    .idea-content:focus {
      outline: 3px solid #b3803b;
      background: #fff6cf;
      border: 1px solid #b3803b;
    }

    /* metadata row inside card */
    .idea-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.8rem;
      margin-top: 0.5rem;
      border-top: 2px solid #ffda8a;
      padding-top: 1rem;
    }

    .idea-tag {
      background: #342d1e;
      color: #ffdfa0;
      padding: 0.3rem 1.2rem;
      border-radius: 40px;
      font-size: 1rem;
      font-weight: 500;
      letter-spacing: 0.4px;
      border: 1px solid #fabb4f;
    }

    .button-group {
      display: flex;
      gap: 0.8rem;
    }

    .action-btn {
      background: #2a2f4b;
      border: none;
      color: white;
      font-size: 1.3rem;
      padding: 0.6rem 1.6rem;
      border-radius: 40px;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-weight: 500;
      cursor: pointer;
      transition: 0.15s;
      border: 1px solid #6b7fff66;
      box-shadow: 0 5px 12px #00000050;
    }

    .action-btn:hover {
      background: #3f4680;
      border-color: #bccaff;
      transform: scale(1.03);
    }

    .action-btn:active {
      transform: scale(0.97);
    }

    .action-btn.danger {
      background: #572c2c;
      border-color: #ff7777aa;
    }
    .action-btn.danger:hover {
      background: #823b3b;
    }

    /* bottom history strip â€“ previous ideas (one by one archive) */
    .history-panel {
      background: #0f1222dd;
      border-radius: 2.5rem;
      padding: 1.8rem 1.5rem 1.5rem 1.5rem;
      border: 1px solid #5566aa55;
      backdrop-filter: blur(4px);
    }

    .history-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 1.2rem;
      color: #b1befa;
      font-size: 1.2rem;
      font-weight: 300;
      letter-spacing: 1px;
    }

    .history-header span {
      font-size: 1.7rem;
    }

    .history-scroll {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
      min-height: 80px;
    }

    .history-chip {
      background: #2b2f50;
      border-radius: 50px;
      padding: 0.8rem 1.8rem;
      font-size: 1.2rem;
      color: #efeacb;
      box-shadow: 0 5px 0 #12142b;
      border: 1px solid #b1a158;
      display: inline-flex;
      align-items: center;
      gap: 12px;
      transition: 0.1s;
      max-width: 280px;
      word-break: break-word;
    }

    .history-chip .chip-index {
      background: #4d5075;
      border-radius: 40px;
      padding: 0.1rem 0.8rem;
      font-weight: 600;
      color: white;
    }

    .history-chip .chip-text {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 160px;
    }

    .history-chip .restore-chip {
      background: none;
      border: none;
      color: #ffd966;
      font-size: 1.3rem;
      cursor: pointer;
      padding: 0 5px;
      border-radius: 20px;
    }
    .history-chip .restore-chip:hover {
      color: white;
      transform: scale(1.2);
    }

    .empty-history {
      color: #68709b;
      font-style: italic;
      padding: 1.2rem 1rem;
      font-size: 1.2rem;
      border: 2px dashed #4f5781;
      border-radius: 60px;
      width: 100%;
      text-align: center;
    }

    /* simple footer note */
    .foot-note {
      margin-top: 1.5rem;
      text-align: right;
      color: #6b72a1;
      font-size: 0.9rem;
      border-top: 1px solid #33406e;
      padding-top: 1rem;
    }

    /* color-dot for current note (used to show uniqueness) */
    .color-dot {
      display: inline-block;
      width: 18px;
      height: 18px;
      border-radius: 18px;
      background: #f7cf7c;
      margin-right: 8px;
      box-shadow: 0 0 0 2px #1c1f33;
    }
  </style>
</head>
<body>
  <div class="one-by-one-board">
    <div class="board-header">
      <div class="title-block">
        <h1>ðŸ§© oneÂ·byÂ·one</h1>
        <div class="step-indicator">
          <span class="step-number" id="stepCounter">1</span>
          <span>current idea</span>
        </div>
      </div>
      <div>
        <!-- subtle color hint: every new idea gets a unique background (cycled) -->
        <div style="display: flex; align-items: center; gap: 8px; background: #1b1f39; padding: 0.5rem 1.2rem; border-radius: 60px;">
          <span class="color-dot" id="currentColorDot"></span>
          <span style="color:#b7bff0">each gets own color</span>
        </div>
      </div>
    </div>

    <!-- main stage: only one idea at a time -->
    <div class="idea-stage">
      <div class="single-note" id="currentNoteCard">
        <!-- content editable paragraph -->
        <div class="idea-content" id="ideaContent" contenteditable="true" role="textbox" aria-multiline="true">
          first unique idea
        </div>
        <div class="idea-meta">
          <div class="idea-tag" id="ideaTag">ðŸŒˆ original</div>
          <div class="button-group">
            <button class="action-btn" id="nextBtn">âœ¨ next &nbsp;â†’</button>
            <button class="action-btn danger" id="resetBtn">â†º reset</button>
          </div>
        </div>
      </div>
    </div>

    <!-- history / archive: one by one list of previous ideas -->
    <div class="history-panel">
      <div class="history-header">
        <span>ðŸ“‹</span> previous ideas (each unique)
      </div>
      <div class="history-scroll" id="historyContainer">
        <!-- filled dynamically -->
        <div class="empty-history">âœ¨ your next idea will appear here</div>
      </div>
    </div>
    <div class="foot-note">
      âš¡ one at a time â€” edit, then move forward
    </div>
  </div>

  <script>
    (function() {
      // --- state: only one current idea, and a list of previous unique ideas
      let currentIdea = {
        text: 'first unique idea',
        color: '#fcf5e6',      // base light yellow
        timestamp: Date.now(),
        id: 'initial'
      };

      // previous ideas array (each with text, color, id)
      let previousIdeas = [];

      // a pool of fresh background colors for each new idea (unique look)
      const colorPalette = [
        '#feff9c', // light lemon
        '#ffccb3', // peach
        '#c5e0b4', // soft green
        '#b4d9e6', // powder blue
        '#e3d7ff', // lavender
        '#fbc8d5', // blush pink
        '#fff2b5', // vanilla
        '#d3d3a4', // sage
        '#f6c9a4', // apricot
        '#c1b0e5', // periwinkle
        '#f9acb5', // coral pink
        '#b0e0c9'  // mint
      ];

      // helper to get a random color from palette (ensuring some variation)
      function getRandomPaletteColor() {
        return colorPalette[Math.floor(Math.random() * colorPalette.length)];
      }

      // for initial we set first color manually from palette (light lemon-ish)
      // but we already set #fcf5e6 as default, we can reassign for consistency
      currentIdea.color = '#feff9c'; // start with classic sticky

      // DOM elements
      const ideaContentDiv = document.getElementById('ideaContent');
      const ideaTag = document.getElementById('ideaTag');
      const stepCounter = document.getElementById('stepCounter');
      const currentColorDot = document.getElementById('currentColorDot');
      const historyContainer = document.getElementById('historyContainer');
      const nextBtn = document.getElementById('nextBtn');
      const resetBtn = document.getElementById('resetBtn');
      const currentNoteCard = document.getElementById('currentNoteCard');

      // helper to render the current idea (UI reflect currentIdea)
      function renderCurrentIdea() {
        ideaContentDiv.innerText = currentIdea.text;    // use innerText to avoid html
        // update card background
        const noteCard = document.querySelector('.single-note');
        if (noteCard) {
          noteCard.style.backgroundColor = currentIdea.color;
          noteCard.style.transition = 'background 0.3s';
        }
        // update color dot
        currentColorDot.style.backgroundColor = currentIdea.color;
        // update tag with a little uniqueness identifier
        const shortId = currentIdea.id ? currentIdea.id.slice(-4) : '****';
        ideaTag.innerHTML = `#${shortId} Â· ${new Date(currentIdea.timestamp).toLocaleTimeString().slice(0,5)}`;
        stepCounter.innerText = previousIdeas.length + 1;   // current step = previous + 1
      }

      // render history list (previous ideas)
      function renderHistory() {
        const container = historyContainer;
        // clear container
        container.innerHTML = '';

        if (previousIdeas.length === 0) {
          container.innerHTML = '<div class="empty-history">âœ¨ finished ideas will stack here</div>';
          return;
        }

        // loop through previous ideas (reverse order so newest first)
        const reversed = [...previousIdeas].reverse();
        for (let i = 0; i < reversed.length; i++) {
          const idea = reversed[i];
          const chip = document.createElement('div');
          chip.className = 'history-chip';
          chip.style.backgroundColor = idea.color; // keep unique background
          chip.style.borderLeft = '4px solid rgba(0,0,0,0.2)';

          const indexSpan = document.createElement('span');
          indexSpan.className = 'chip-index';
          indexSpan.innerText = `#${idea.id.slice(-4)}`;

          const textSpan = document.createElement('span');
          textSpan.className = 'chip-text';
          textSpan.innerText = idea.text;

          const restoreBtn = document.createElement('button');
          restoreBtn.className = 'restore-chip';
          restoreBtn.innerHTML = 'â†©';
          restoreBtn.title = 'bring back this idea (as current)';
          // restore action: set current to this idea, remove from previous
          restoreBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            restoreIdea(idea.id);
          });

          chip.appendChild(indexSpan);
          chip.appendChild(textSpan);
          chip.appendChild(restoreBtn);
          container.appendChild(chip);
        }
      }

      // restore a previous idea by id
      function restoreIdea(id) {
        const index = previousIdeas.findIndex(idea => idea.id === id);
        if (index === -1) return;

        // get the idea to restore
        const restored = previousIdeas[index];

        // move current idea into previous (swap)
        const oldCurrent = { ...currentIdea };

        // replace current with restored
        currentIdea = { ...restored };

        // remove restored from previous
        previousIdeas.splice(index, 1);

        // push old current into previous (but ensure it's not identical)
        // but avoid duplication if same id? oldCurrent.id !== restored.id always
        previousIdeas.push(oldCurrent);

        // re-render everything
        renderCurrentIdea();
        renderHistory();
      }

      // move to next idea: archive current, create fresh unique
      function moveToNext() {
        // archive current idea (push into previousIdeas)
        const ideaToArchive = {
          text: currentIdea.text,
          color: currentIdea.color,
          timestamp: currentIdea.timestamp,
          id: currentIdea.id
        };
        previousIdeas.push(ideaToArchive);

        // generate new unique idea
        const newText = 'âœï¸ new unique thought...';
        const newColor = getRandomPaletteColor();  // each gets different color
        const newId = 'note_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8);
        const newTimestamp = Date.now();

        currentIdea = {
          text: newText,
          color: newColor,
          timestamp: newTimestamp,
          id: newId
        };

        // update UI
        renderCurrentIdea();
        renderHistory();

        // after moving, put focus on content for immediate typing
        ideaContentDiv.focus();
      }

      // reset everything (start fresh, clear history, set default idea)
      function resetBoard() {
        if (confirm('ðŸ§¼ start a new unique chain? current idea will be lost.')) {
          // reset previous ideas
          previousIdeas = [];
          // create brand new first idea
          currentIdea = {
            text: 'fresh start',
            color: getRandomPaletteColor(),
            timestamp: Date.now(),
            id: 'init_' + Date.now().toString(36)
          };
          renderCurrentIdea();
          renderHistory();
          ideaContentDiv.focus();
        }
      }

      // sync current text from contenteditable (on input)
      ideaContentDiv.addEventListener('input', (e) => {
        currentIdea.text = e.target.innerText;
        // we don't auto-save to history, only when moving next / restore
        // but keep current idea synced
      });

      // next button click
      nextBtn.addEventListener('click', () => {
        // before archiving, capture latest text from editable (already synced via input)
        moveToNext();
      });

      // reset button
      resetBtn.addEventListener('click', resetBoard);

      // initialize
      function initBoard() {
        // set first idea values (ensure color and id)
        currentIdea.color = '#feff9c';   // from palette
        currentIdea.id = 'init_' + Date.now().toString(36) + 'a1';
        currentIdea.timestamp = Date.now();
        // if text content is still default, keep
        if (ideaContentDiv.innerText.trim() === '') {
          currentIdea.text = 'first unique idea';
        } else {
          currentIdea.text = ideaContentDiv.innerText;
        }
        renderCurrentIdea();
        renderHistory();
      }

      initBoard();

      // additional: listen for blur to capture latest text (just in case)
      ideaContentDiv.addEventListener('blur', () => {
        currentIdea.text = ideaContentDiv.innerText;
      });

      // make sure each step increments uniqueness: also pressing Enter from editable?
      // not needed. Extra: you can also press "Cmd/Ctrl + Enter" to move next?
      ideaContentDiv.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
          e.preventDefault();
          moveToNext();
        }
      });

      // extra small: double click on stage also go next? optional, we keep only button.
      // to keep interface clean, no accidental triggers.

      // uniqueness guarantee: history panel shows distinct colors.
      // on restore, we maintain uniqueness because colors remain attached.
    })();
  </script>
</body>
</html>